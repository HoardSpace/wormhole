<!DOCTYPE html>
<html>
<head>
  <title>Wormhole simulation</title>
  <meta charset="utf-8">
  <style>
  *, *::before, *::after {
    margin: 0;
    box-sizing: border-box;
  }
  body, html {
    width: 100%;
    height: 100%;
  }
  body {
    margin: 0;
    background: #000;
    color: #fff;
    font-size: 12px;
    font-family: sans-serif;
  }
  #container {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
  }
  canvas {
    display: block;
    border-radius: 10px;
  }

  .ui label {
    cursor: pointer;
  }

  .renderer-settings {
    position: fixed;
    bottom: 0;
    right: 0;
    z-index: 10;
    text-align: right;
    padding: 1em;
    max-width: 30em;
  }
  .renderer-settings > label {
    display: block;
  }

  .ui-settings {
    position: fixed;
    bottom: 0;
    left: 0;
    z-index: 11;
    text-align: left;
    padding: 1em;
    background: rgba(0,0,0,0.5);
  }

  .ui {
    transition: all 0.2s ease;
  }

  .no-ui .ui {
    opacity: 0;
  }

  .no-ui .ui-settings:hover {
    opacity: 1;
  }

  .no-ui .renderer-settings {
    transform: translateX(100%);
  }

  #introduction {
    width: 100%;
    max-width: 600px;
    background: rgba(20,20,20, 0.95);
    box-shadow: 0 10px 20px #000;
    padding: 1.5em;
    position: absolute;
    top: 1em;
    left: 50%;
    transform: translateX(-50%);
    z-index: 20;
    font-size: 14px;
    transition: transform 0.5s cubic-bezier(.35,-0.29,.25,1);
  }

  #introduction.hidden {
    transform: translateY(-120%) translateX(-50%);
  }

  #introduction h1 {
    margin-bottom: 1em;
    text-align: center;
  }

  #introduction p, #introduction ul {
    line-height: 1.5;
    margin: 0 0 1em;
  }

  #introduction a {
    color: #387aff;
  }

  .info {
    color: #888;
    text-align: center;
    border-top: 1px solid #000;
    padding-top: 1em;
  }

  .caution {
    color: #f0e033;
  }
  </style>
</head>
<body>

<div id="introduction">
  <h1>Travel through a wormhole</h1>
  <p>So on the internet it's kind of hard to get a realistic impression of what travelling through a wormhole could look like. If you look around a bit you'll find things like:
  </p>
  <ul>
    <li><a target="_blank" href="https://www.youtube.com/watch?v=8tX7KQSKMtQ">this wormhole simulation video</a> based on real maths behing general relativity,
    <li><a target="_blank" href="https://www.youtube.com/watch?v=Ln2SGm9gEuE">this scene of the movie "Interstellar"</a>, which is epic but completely inaccurate for the interior (the exterior seems legit), and
    <li><a target="_blank" href="https://sirxemic.github.io/Interstellar">this "Interstellar" thing I made</a>, which is maybe sort of accurate, but in reality is just hacked together without using the maths behind general relativity.
  </ul>
  <p>None of these show what a wormhole with a long "throat" would look like. This simulation does.</p>
  <p class="info">Click anywhere to continue</p>
</div>

<div id="container">
</div>

<div class="ui renderer-settings">
  <h3>Pixel ratio</h3>
  <label><input type="radio" name="resolution" value="4" checked> 1:4</label>
  <label><input type="radio" name="resolution" value="3"> 1:3</label>
  <label><input type="radio" name="resolution" value="2"> 1:2</label>
  <label><input type="radio" name="resolution" value="1"> 1:1</label>
  <p class="caution">Caution: depending on the power of your GPU, changing the pixel ratio might slow your browser to a crawl.</p>
</div>

<div class="ui ui-settings">
  <label><input type="checkbox" name="hide-ui"> Hide UI</label>
</div>

<script type="x-shader/x-vertex" id="vertexShader">
precision highp float;

attribute vec2 position;

uniform mat4 uCameraOrientation;

varying vec3 vRayDir;

void main() {
  vRayDir = (uCameraOrientation * vec4(position.x, position.y, 1.0, 0.0)).xyz;

  gl_Position = vec4(position, 0.0, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="fragmentShader">
precision highp float;

uniform vec3 uCameraPosition;

uniform float uRadiusSquared;
uniform float uThroatLength;

uniform samplerCube uSkybox1;
uniform samplerCube uSkybox2;

varying vec3 vRayDir;

struct State2D {
  vec2 position;
  vec2 direction;
  float distance;
};

struct State3D {
  vec3 position;
  vec3 direction;
  float distance;
};

/**
 *  Util
 */

mat3 rotationMatrix(vec3 axis, float angle) {
  float c = cos(angle),
        s = sin(angle),
        t = 1.0 - c,
        tX = t * axis.x,
        tY = t * axis.y,
        tZ = t * axis.z;

  return mat3(
    tX * axis.x + c, tY * axis.x + s * axis.z, tZ * axis.x - s * axis.y,
    tX * axis.y - s * axis.z, tY * axis.y + c, tZ * axis.y + s * axis.x,
    tX * axis.z + s * axis.y, tY * axis.z - s * axis.x, tZ * axis.z + c
  );
}

/**
 *  Integration stuff
 */

// Solve the direct geodesic problem for spheres.
// That means:
// given a starting point and an initial heading, find the position after traveling
// a certain distance (or angle in the case of the unit sphere) along the geodesic.
void greatCircle(inout vec2 position, inout vec2 direction, float angle) {
  // Convert position and direction to 3D
  float sinY = sin(position.y),
        cosY = cos(position.y),
        sinX = sin(position.x),
        cosX = cos(position.x);

  vec3 pos3D = vec3(sinY * cosX, sinY * sinX, cosY);
  vec3 dir3D = vec3(
    -sinY * sinX * direction.x + cosY * cosX * direction.y,
     sinY * cosX * direction.x + cosY * sinX * direction.y,
    -sinY * direction.y
  );

  // Rotate position and direction
  vec3 axis = cross(pos3D, normalize(dir3D));
  mat3 rotation = rotationMatrix(axis, angle);

  pos3D = rotation * pos3D;
  dir3D = rotation * dir3D;

  // Convert position and direction back to 2D
  position = vec2(
    atan(pos3D.y, pos3D.x),
    acos(clamp(pos3D.z, -1.0, 1.0))
  );

  float xy = 1.0 / dot(pos3D.xy, pos3D.xy);

  direction = vec2(
    (pos3D.x * dir3D.y - pos3D.y * dir3D.x) * xy,
    -dir3D.z
  ) * xy;
}

// Do an integration step in 2D wormhole space.
void step2D(inout State2D ray) {
  float distanceToWormhole = abs(ray.position.x) - uThroatLength;

  float delta = 0.1 / uRadiusSquared;

  if (distanceToWormhole >= 0.0) {
    // We can take bigger integration steps when at a larger distance away from the wormhole.
    delta = (0.1 + 0.02 * distanceToWormhole) / uRadiusSquared;

    // Use backwards euler integration
    float h = delta,
        h2 = h * h,
        x = (ray.position.x / abs(ray.position.x)) * distanceToWormhole,
        x2 = x * x,
        b2 = uRadiusSquared,
        dx = ray.direction.x,
        dx2 = dx * dx,
        dy = ray.direction.y,
        dy2 = dy * dy,

        r2 = b2 + x2,
        hdx = h * dx,
        s = 2.0 * x * hdx,
        t = h2 * (b2 - 3.0 * x2);

    vec2 directionDelta = vec2(
        dy * (x * r2 * r2 - 2.0 * x * t * dx2 + (b2 * b2 - x2 * x2) * hdx),
        -2.0 * (x2 * (x - hdx) + b2 * (x + hdx)) * (dx + h * x * dy2)
    ) * dy * h / (r2 * (r2 + s) - t * (r2 - s) * dy2);

    ray.direction += directionDelta;
  }
  else {
    // Inside the wormhole spacetime is flat, so just compute the distance to the mouth.
    if (ray.position.x >= 0.0 && ray.direction.x < 0.0) {
      delta = (ray.position.x + uThroatLength) / -ray.direction.x;
    }
    else if (ray.position.x >= 0.0 && ray.direction.x > 0.0) {
      delta = (uThroatLength - ray.position.x) / ray.direction.x;
    }
    else if (ray.position.x < 0.0 && ray.direction.x > 0.0) {
      delta = (uThroatLength - ray.position.x) / ray.direction.x;
    }
    else if (ray.position.x < 0.0 && ray.direction.x < 0.0) {
      delta = (ray.position.x + uThroatLength) / -ray.direction.x;
    }
    else {
      // Looks like the camera is pointed into the wormhole's "abyss"
      delta = 1000.0;
    }
  }

  ray.position += ray.direction * delta;

  ray.distance += delta;
}

// Normalize the direction according to the curvature.
void normalizeDirection2D(inout State2D ray) {
  float distanceToWormhole = max(0.0, abs(ray.position.x) - uThroatLength);

  float magnitude = sqrt(
    ray.direction.x * ray.direction.x +
    (distanceToWormhole * distanceToWormhole + uRadiusSquared) * ray.direction.y * ray.direction.y
  );

  ray.direction /= magnitude;
}

// Integrate in 2D wormhole space.
void integrate2D(inout State2D ray) {
  for (int i = 0; i < 128; i++) {
    step2D(ray);
    normalizeDirection2D(ray);
  }
}

// Integrate!
void integrate3D(inout State3D ray) {
  float distanceToWormhole = max(0.0, abs(ray.position.x) - uThroatLength);

  State2D ray2D;
  ray2D.position = vec2(ray.position.x, 0.0);
  ray2D.direction = vec2(
    ray.direction.x,
    sqrt((1.0 - ray.direction.x * ray.direction.x) / (distanceToWormhole * distanceToWormhole + uRadiusSquared))
  );
  ray2D.distance = ray.distance;

  // Integrate in a 2D plane so we don't have to deal with the poles of spherical coordinates. This works
  // because all geodesics around a wormhole lie in a plane...
  // ...that was the idea, but I still get artifacts around the poles. Oh well...
  integrate2D(ray2D);

  // Transform the 2D position and direction back into 3D
  ray.position.x = ray2D.position.x;
  ray.direction.x = ray2D.direction.x;

  greatCircle(ray.position.zy, ray.direction.zy, ray2D.position.y);

  ray.direction.yz = normalize(ray.direction.yz) * ray2D.direction.y;

  ray.distance = ray2D.distance;
}

// Transform a direction given in flat spacetime coordinates to one of the same angle
// in wormhole spacetime coordinates.
void adjustDirection(inout State3D ray) {
  float distanceToWormhole = max(0.0, abs(ray.position.x) - uThroatLength);

  float r = sqrt(distanceToWormhole * distanceToWormhole + uRadiusSquared);
  ray.direction.y /= r;
  ray.direction.z /= r * sin(ray.position.y);
}

// Get the final color given a position and direction.
vec4 getColor(State3D ray) {
  float distanceToWormhole = max(0.0, abs(ray.position.x) - uThroatLength);

  if (distanceToWormhole == 0.0) {
    return vec4(0.0, 0.0, 0.0, 1.0);
  }

  float sinY = sin(ray.position.y),
        cosY = cos(ray.position.y),
        sinZ = sin(ray.position.z),
        cosZ = cos(ray.position.z),
        r = distanceToWormhole * (ray.position.x / abs(ray.position.x));

  vec3 cubeDir = vec3(
     ray.direction.x * sinY * cosZ - r * sinY * sinZ * ray.direction.z + r * cosY * cosZ * ray.direction.y,
    -ray.direction.x * cosY + r * sinY * ray.direction.y,
     ray.direction.x * sinY * sinZ + r * sinY * cosZ * ray.direction.z + r * cosY * sinZ * ray.direction.y
  );

  vec4 skybox1Color = textureCube(uSkybox1, cubeDir);
  vec4 skybox2Color = textureCube(uSkybox2, cubeDir);

  float merge = 0.5 - clamp(ray.position.x, -0.5, 0.5);
  vec4 color = mix(skybox1Color, skybox2Color, merge);

  // Prettify the thing where everything becomes infinite
  const float cutoffStart = 150.0;
  const float cutoffEnd = 800.0;
  if (ray.distance > cutoffStart) {
    color *= max(0.0, (cutoffEnd - ray.distance) / (cutoffEnd - cutoffStart));
  }

  return color;
}

void main()
{
  State3D ray;
  ray.position = uCameraPosition;
  ray.direction = normalize(vRayDir);
  ray.distance = 0.0;

  // At this point rayDir makes sense in flat spacetime, but in curved space time
  // it needs to be slightly adjusted.
  adjustDirection(ray);

  // Integrate in wormhole space coordinates
  integrate3D(ray);

  gl_FragColor = getColor(ray);
}
</script>
<script src="js/lib/three.min.js"></script>
<script src="js/dist.js"></script>
</body>
</html>
